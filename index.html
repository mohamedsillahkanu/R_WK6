    
    <div class="container">
        <h1 id="week6">üìÖ Week 6: Statistical Analysis for Malaria Data</h1>
        <link rel="stylesheet" href="styles.css">
        
        <p>This week, we will:<br>
        ‚úÖ <strong>Compare malaria rates between groups</strong> using t-tests and ANOVA<br>
        ‚úÖ <strong>Identify relationships between variables</strong> using correlation analysis<br>
        ‚úÖ <strong>Build predictive models</strong> using linear regression<br>
        ‚úÖ <strong>Create statistical reports</strong> with proper interpretation of results</p>
        
        <hr>
        
        <h2 id="hypothesis-testing">1Ô∏è‚É£ Hypothesis Testing for Malaria Data</h2>
        
        <h3>Why Conduct Hypothesis Tests?</h3>
        <p>üìå <strong>Hypothesis testing</strong> helps determine if observed differences in malaria rates between groups (e.g., regions, treatment groups, time periods) are statistically significant or likely due to random chance.</p>
        
        <h3>Step 1: Conducting a Two-Sample t-test</h3>
        <div class="r-code">
            <code>
# Load required packages
library(dplyr)
library(ggplot2)

# Load malaria dataset
malaria_data <- read.csv("malaria_data.csv")

# Compare malaria cases between urban and rural areas
urban_cases <- filter(malaria_data, area_type == "Urban")$cases
rural_cases <- filter(malaria_data, area_type == "Rural")$cases

# Visualize the data with boxplots before testing
ggplot(malaria_data, aes(x = area_type, y = cases, fill = area_type)) +
  geom_boxplot() +
  labs(
    title = "Distribution of Malaria Cases by Area Type",
    x = "Area Type",
    y = "Number of Cases"
  ) +
  theme_minimal()

# Perform t-test
t_test_result <- t.test(urban_cases, rural_cases)

# Print the results
print(t_test_result)

# Interpret the results
alpha <- 0.05
if(t_test_result$p.value < alpha) {
  cat("There is a statistically significant difference in malaria cases between urban and rural areas (p =", 
      round(t_test_result$p.value, 4), ").\n")
} else {
  cat("There is no statistically significant difference in malaria cases between urban and rural areas (p =", 
      round(t_test_result$p.value, 4), ").\n")
}
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî <code>t.test()</code> compares the means of two independent groups<br>
            ‚úî The null hypothesis (H‚ÇÄ) is that there is no difference between means<br>
            ‚úî The alternative hypothesis (H‚ÇÅ) is that there is a difference<br>
            ‚úî If p-value < Œ± (typically 0.05), we reject the null hypothesis</p>
        </div>
        
        <hr>
        
        <h3>Step 2: Paired t-tests for Before-After Comparisons</h3>
        <div class="r-code">
            <code>
# Compare malaria cases before and after an intervention
pre_intervention <- malaria_data %>%
  filter(period == "Pre-intervention") %>%
  select(site_id, cases)

post_intervention <- malaria_data %>%
  filter(period == "Post-intervention") %>%
  select(site_id, cases)

# Merge the data
intervention_data <- inner_join(
  pre_intervention, post_intervention,
  by = "site_id",
  suffix = c("_pre", "_post")
)

# Visualize before-after comparison
intervention_long <- intervention_data %>%
  tidyr::pivot_longer(
    cols = c(cases_pre, cases_post),
    names_to = "period",
    values_to = "cases"
  ) %>%
  mutate(period = ifelse(period == "cases_pre", "Pre-intervention", "Post-intervention"))

ggplot(intervention_long, aes(x = period, y = cases)) +
  geom_boxplot(fill = "lightblue") +
  geom_line(aes(group = site_id), alpha = 0.3) +
  labs(
    title = "Malaria Cases Before and After Intervention",
    x = "Period",
    y = "Number of Cases"
  ) +
  theme_minimal()

# Perform paired t-test
paired_test <- t.test(
  intervention_data$cases_pre,
  intervention_data$cases_post,
  paired = TRUE
)

print(paired_test)

# Calculate percent reduction
mean_reduction <- mean(intervention_data$cases_pre - intervention_data$cases_post)
percent_reduction <- (mean_reduction / mean(intervention_data$cases_pre)) * 100

cat("Mean reduction in cases:", round(mean_reduction, 2), 
    "cases (", round(percent_reduction, 1), "% reduction)\n")
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî <code>paired = TRUE</code> tells R that observations are from the same sites (before & after)<br>
            ‚úî Paired tests have greater statistical power when comparing repeated measurements<br>
            ‚úî The visualization with lines connecting pre/post values shows site-specific changes<br>
            ‚úî We can also quantify the practical significance with the percent reduction</p>
        </div>
        
        <hr>
        
        <h3>Step 3: One-Way ANOVA for Comparing Multiple Groups</h3>
        <div class="r-code">
            <code>
# Compare malaria cases across different regions
ggplot(malaria_data, aes(x = region, y = cases, fill = region)) +
  geom_boxplot() +
  labs(
    title = "Distribution of Malaria Cases by Region",
    x = "Region",
    y = "Number of Cases"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Perform one-way ANOVA
anova_result <- aov(cases ~ region, data = malaria_data)

# Print the ANOVA summary
summary(anova_result)

# If ANOVA is significant, perform post-hoc tests to identify which groups differ
if(summary(anova_result)[[1]][["Pr(>F)"]][1] < 0.05) {
  cat("The ANOVA test shows significant differences between regions.\n")
  cat("Performing Tukey's HSD post-hoc test to identify which regions differ:\n\n")
  
  # Tukey's Honest Significant Difference test
  tukey_result <- TukeyHSD(anova_result)
  print(tukey_result)
  
  # Visualize the Tukey HSD results
  plot(tukey_result)
} else {
  cat("The ANOVA test shows no significant differences between regions.")
}
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî ANOVA (Analysis of Variance) compares means across multiple groups<br>
            ‚úî <code>aov()</code> fits the ANOVA model<br>
            ‚úî If the overall ANOVA is significant, we perform post-hoc tests to identify specific differences<br>
            ‚úî <code>TukeyHSD()</code> performs pairwise comparisons with correction for multiple testing</p>
        </div>
        
        <hr>
        
        <h3>Step 4: Non-parametric Alternatives</h3>
        <div class="r-code">
            <code>
# Check if data is normally distributed
shapiro_test <- shapiro.test(malaria_data$cases)
print(shapiro_test)

# If p < 0.05, data is not normally distributed, use non-parametric tests
if(shapiro_test$p.value < 0.05) {
  cat("Data is not normally distributed. Using non-parametric tests.\n\n")
  
  # For two groups, use Wilcoxon rank-sum test (Mann-Whitney U test)
  wilcox_result <- wilcox.test(
    filter(malaria_data, area_type == "Urban")$cases,
    filter(malaria_data, area_type == "Rural")$cases
  )
  
  print(wilcox_result)
  
  # For multiple groups, use Kruskal-Wallis test (non-parametric ANOVA)
  kruskal_result <- kruskal.test(cases ~ region, data = malaria_data)
  print(kruskal_result)
  
  # If Kruskal-Wallis is significant, perform Dunn's test for pairwise comparisons
  if(kruskal_result$p.value < 0.05) {
    if(!require(dunn.test)) {
      install.packages("dunn.test")
      library(dunn.test)
    }
    
    dunn_result <- dunn.test(
      x = malaria_data$cases,
      g = malaria_data$region,
      method = "bonferroni"
    )
  }
} else {
  cat("Data appears to be normally distributed. Parametric tests are appropriate.\n")
}
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî <code>shapiro.test()</code> checks if data follows a normal distribution<br>
            ‚úî Non-parametric tests are more appropriate when data is skewed or has outliers<br>
            ‚úî <code>wilcox.test()</code> is the non-parametric alternative to the t-test<br>
            ‚úî <code>kruskal.test()</code> is the non-parametric alternative to ANOVA<br>
            ‚úî <code>dunn.test()</code> provides pairwise comparisons for Kruskal-Wallis</p>
        </div>
        
        <hr>
        
        <h2 id="correlation">2Ô∏è‚É£ Correlation Analysis for Malaria Data</h2>
        
        <h3>Step 1: Basic Correlation Between Variables</h3>
        <div class="r-code">
            <code>
# Check correlation between malaria cases and environmental factors
# First, let's create a correlation matrix
correlation_vars <- c("cases", "rainfall_mm", "temperature_avg", "humidity_percent")
correlation_data <- malaria_data %>% select(all_of(correlation_vars))

# Calculate correlation matrix
correlation_matrix <- cor(correlation_data, use = "pairwise.complete.obs")
print(correlation_matrix)

# Visualize with a correlation plot
if(!require(corrplot)) {
  install.packages("corrplot")
  library(corrplot)
}

corrplot(correlation_matrix, 
         method = "circle", 
         type = "upper", 
         tl.col = "black",
         tl.srt = 45,
         addCoef.col = "black")

# Test statistical significance of correlations
correlation_test <- cor.test(malaria_data$cases, malaria_data$rainfall_mm)
print(correlation_test)

# Interpret the result
if(correlation_test$p.value < 0.05) {
  cat("There is a statistically significant correlation between malaria cases and rainfall (r =", 
      round(correlation_test$estimate, 2), 
      ", p =", round(correlation_test$p.value, 4), ").\n")
} else {
  cat("There is no statistically significant correlation between malaria cases and rainfall (r =", 
      round(correlation_test$estimate, 2), 
      ", p =", round(correlation_test$p.value, 4), ").\n")
}
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî <code>cor()</code> calculates Pearson correlation coefficients between variables<br>
            ‚úî <code>use = "pairwise.complete.obs"</code> handles missing values by using all available pairs<br>
            ‚úî <code>corrplot()</code> creates a visual representation of the correlation matrix<br>
            ‚úî <code>cor.test()</code> tests if the correlation is significantly different from zero</p>
        </div>
        
        <hr>
        
        <h3>Step 2: Visualizing Correlations with Scatter Plots</h3>
        <div class="r-code">
            <code>
# Create scatter plots for key correlations
ggplot(malaria_data, aes(x = rainfall_mm, y = cases)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", color = "blue") +
  labs(
    title = "Relationship Between Rainfall and Malaria Cases",
    x = "Monthly Rainfall (mm)",
    y = "Number of Malaria Cases"
  ) +
  theme_minimal()

# Create a matrix of scatter plots for multiple variables
if(!require(GGally)) {
  install.packages("GGally")
  library(GGally)
}

ggpairs(correlation_data, 
        columns = 1:4,
        title = "Correlation Matrix for Malaria and Environmental Factors")

# Create a scatter plot with temporal information
ggplot(malaria_data, aes(x = rainfall_mm, y = cases, color = factor(year))) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(
    title = "Rainfall vs. Malaria Cases by Year",
    x = "Monthly Rainfall (mm)",
    y = "Number of Malaria Cases",
    color = "Year"
  ) +
  theme_minimal()
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî Scatter plots visually show the relationship between two variables<br>
            ‚úî <code>geom_smooth(method = "lm")</code> adds a linear trend line<br>
            ‚úî <code>ggpairs()</code> creates a matrix of scatter plots, histograms, and correlation coefficients<br>
            ‚úî Adding color by year shows if the relationship changes over time</p>
        </div>
        
        <hr>
        
        <h3>Step 3: Time-Lagged Correlations</h3>
        <div class="r-code">
            <code>
# Analyze time-lagged correlations (e.g., rainfall affecting malaria cases with a delay)
# First, ensure data is sorted by location and time
time_series_data <- malaria_data %>%
  arrange(site_id, year, month) %>%
  group_by(site_id) %>%
  mutate(
    rainfall_lag1 = lag(rainfall_mm, 1),  # Previous month
    rainfall_lag2 = lag(rainfall_mm, 2),  # Two months ago
    rainfall_lag3 = lag(rainfall_mm, 3)   # Three months ago
  ) %>%
  ungroup()

# Calculate correlations at different lags
lag_correlations <- data.frame(
  lag = c(0, 1, 2, 3),
  correlation = c(
    cor(time_series_data$cases, time_series_data$rainfall_mm, use = "pairwise.complete.obs"),
    cor(time_series_data$cases, time_series_data$rainfall_lag1, use = "pairwise.complete.obs"),
    cor(time_series_data$cases, time_series_data$rainfall_lag2, use = "pairwise.complete.obs"),
    cor(time_series_data$cases, time_series_data$rainfall_lag3, use = "pairwise.complete.obs")
  )
)

print(lag_correlations)

# Visualize lag correlations
ggplot(lag_correlations, aes(x = lag, y = correlation)) +
  geom_line(color = "blue", size = 1) +
  geom_point(color = "blue", size = 3) +
  labs(
    title = "Correlation Between Malaria Cases and Rainfall at Different Time Lags",
    x = "Lag (Months)",
    y = "Correlation Coefficient (r)"
  ) +
  theme_minimal()

# Identify the lag with the strongest correlation
max_lag <- lag_correlations$lag[which.max(abs(lag_correlations$correlation))]
max_cor <- lag_correlations$correlation[which.max(abs(lag_correlations$correlation))]

cat("The strongest correlation between rainfall and malaria cases occurs with a lag of", 
    max_lag, "months (r =", round(max_cor, 2), ").\n")
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî <code>lag()</code> function creates variables with values from previous time points<br>
            ‚úî Time-lagged correlations help identify delayed effects of environmental factors<br>
            ‚úî This is particularly important for malaria as mosquito development takes time<br>
            ‚úî The lag with the strongest correlation suggests the time delay between rainfall and malaria cases</p>
        </div>
        
        <hr>
        
        <h3>Step 4: Correlation with Categorical Variables</h3>
        <div class="r-code">
            <code>
# Examine relationships between categorical variables and malaria cases
# For binary variables, we can use point-biserial correlation (special case of Pearson)

# First, convert categorical variables to numeric if needed
malaria_data$intervention_numeric <- ifelse(malaria_data$intervention == "Yes", 1, 0)

# Calculate point-biserial correlation
intervention_cor <- cor.test(malaria_data$cases, malaria_data$intervention_numeric)
print(intervention_cor)

# For categorical variables with multiple levels, use ANOVA or boxplots
ggplot(malaria_data, aes(x = socioeconomic_status, y = cases, fill = socioeconomic_status)) +
  geom_boxplot() +
  labs(
    title = "Malaria Cases by Socioeconomic Status",
    x = "Socioeconomic Status",
    y = "Number of Cases"
  ) +
  theme_minimal()

# Use eta-squared to quantify the strength of relationship
if(!require(effectsize)) {
  install.packages("effectsize")
  library(effectsize)
}

anova_model <- aov(cases ~ socioeconomic_status, data = malaria_data)
eta_squared_result <- eta_squared(anova_model)
print(eta_squared_result)

# Interpretation:
# Œ∑¬≤ < 0.01: Very small effect
# 0.01 ‚â§ Œ∑¬≤ < 0.06: Small effect
# 0.06 ‚â§ Œ∑¬≤ < 0.14: Medium effect
# Œ∑¬≤ ‚â• 0.14: Large effect
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî For binary categorical variables, point-biserial correlation (a special case of Pearson correlation) can be used<br>
            ‚úî For categorical variables with multiple levels, ANOVA and visualization with boxplots are appropriate<br>
            ‚úî <code>eta_squared()</code> quantifies the proportion of variance in the outcome variable that is explained by the categorical variable<br>
            ‚úî This provides a standardized effect size measure for categorical predictors</p>
        </div>
        
        <hr>
        
        <h2 id="regression">3Ô∏è‚É£ Linear Regression for Malaria Data</h2>
        
        <h3>Why Use Regression?</h3>
        <p>üìå <strong>Regression analysis</strong> allows us to model the relationship between malaria cases and potential predictor variables, identify significant factors influencing malaria transmission, and make predictions based on those relationships.</p>
        
        <h3>Step 1: Simple Linear Regression</h3>
        <div class="r-code">
            <code>
# Simple linear regression with one predictor
# Predict malaria cases based on rainfall
simple_model <- lm(cases ~ rainfall_mm, data = malaria_data)

# Examine the model summary
summary(simple_model)

# Visualize the relationship
ggplot(malaria_data, aes(x = rainfall_mm, y = cases)) +
  geom_point() +
  geom_smooth(method = "lm", color = "blue") +
  labs(
    title = "Linear Regression: Malaria Cases vs. Rainfall",
    x = "Monthly Rainfall (mm)",
    y = "Number of Malaria Cases"
  ) +
  theme_minimal()

# Make predictions with the model
new_data <- data.frame(rainfall_mm = c(50, 100, 150, 200, 250))
predictions <- predict(simple_model, newdata = new_data, interval = "confidence")

prediction_df <- cbind(new_data, predictions)
print(prediction_df)

# Plot with prediction intervals
ggplot(malaria_data, aes(x = rainfall_mm, y = cases)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", fill = "lightblue") +
  geom_line(data = prediction_df, aes(y = fit), color = "red", size = 1) +
  geom_ribbon(data = prediction_df, aes(y = fit, ymin = lwr, ymax = upr), 
              alpha = 0.2, fill = "red") +
  labs(
    title = "Linear Regression with Confidence Intervals",
    x = "Monthly Rainfall (mm)",
    y = "Number of Malaria Cases"
  ) +
  theme_minimal()
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî <code>lm()</code> fits a linear regression model<br>
            ‚úî <code>summary(model)</code> provides detailed statistics including coefficients, p-values, and R-squared<br>
            ‚úî <code>predict(model, newdata, interval = "confidence")</code> generates predictions with confidence intervals<br>
            ‚úî The slope coefficient represents the expected change in malaria cases for a 1 mm increase in rainfall</p>
        </div>
        
        <hr>
        
        <h3>Step 2: Multiple Linear Regression</h3>
        <div class="r-code">
            <code>
# Multiple linear regression with several predictors
multiple_model <- lm(
  cases ~ rainfall_mm + temperature_avg + humidity_percent + population_density,
  data = malaria_data
)

# Examine the model summary
summary(multiple_model)

# Visualize coefficients
if(!require(jtools)) {
  install.packages("jtools")
  library(jtools)
}

plot_summs(multiple_model, scale = TRUE, plot.distributions = TRUE)

# Check for multicollinearity
if(!require(car)) {
  install.packages("car")
  library(car)
}

vif_results <- vif(multiple_model)
print(vif_results)

# Interpret VIF results:
cat("Variables with VIF > 5 may have problematic multicollinearity.\n")
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî Multiple regression includes several predictor variables in the same model<br>
            ‚úî <code>plot_summs()</code> visualizes coefficient estimates with confidence intervals<br>
            ‚úî <code>scale = TRUE</code> standardizes coefficients to compare their relative importance<br>
            ‚úî <code>vif()</code> calculates Variance Inflation Factors to detect multicollinearity<br>
            ‚úî Multicollinearity occurs when predictors are highly correlated with each other</p>
        </div>
        
        <hr>
        
        <h3>Step 3: Model Selection and Comparison</h3>
        <div class="r-code">
            <code>
# Build and compare different models
model1 <- lm(cases ~ rainfall_mm, data = malaria_data)
model2 <- lm(cases ~ rainfall_mm + temperature_avg, data = malaria_data)
model3 <- lm(cases ~ rainfall_mm + temperature_avg + humidity_percent, data = malaria_data)
model4 <- lm(cases ~ rainfall_mm + temperature_avg + humidity_percent + population_density, data = malaria_data)

# Compare models using AIC (Akaike Information Criterion)
models_AIC <- AIC(model1, model2, model3, model4)
print(models_AIC)

# Compare models using anova (Analysis of Variance)
anova_comparison <- anova(model1, model2, model3, model4)
print(anova_comparison)

# Automated model selection using step function
# Start with full model and perform backward selection
step_model <- step(model4, direction = "backward")
summary(step_model)

# Compare R-squared values
models_rsquared <- data.frame(
  Model = c("Model 1 (Rainfall)", 
            "Model 2 (Rainfall + Temperature)", 
            "Model 3 (Rainfall + Temperature + Humidity)",
            "Model 4 (All variables)"),
  R_squared = c(
    summary(model1)$r.squared,
    summary(model2)$r.squared,
    summary(model3)$r.squared,
    summary(model4)$r.squared
  ),
  Adj_R_squared = c(
    summary(model1)$adj.r.squared,
    summary(model2)$adj.r.squared,
    summary(model3)$adj.r.squared,
    summary(model4)$adj.r.squared
  )
)

print(models_rsquared)
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî Model selection involves comparing different combinations of predictors<br>
            ‚úî <code>AIC()</code> calculates the Akaike Information Criterion - lower values indicate better models<br>
            ‚úî <code>anova()</code> tests if adding variables significantly improves the model<br>
            ‚úî <code>step()</code> performs automated model selection based on AIC<br>
            ‚úî Adjusted R-squared accounts for the number of predictors and helps prevent overfitting</p>
        </div>
        
        <hr>
        
        <h3>Step 4: Model Diagnostics and Assumptions</h3>
        <div class="r-code">
            <code>
# Check regression assumptions
par(mfrow = c(2, 2))
plot(step_model)
par(mfrow = c(1, 1))

# Check for normality of residuals
shapiro.test(residuals(step_model))

# Check for influential observations
influence_measures <- influence.measures(step_model)
influential_obs <- which(influence_measures$is.inf[, "cook.d"])
cat("Potentially influential observations (rows):", influential_obs, "\n")

# Robust regression if needed
if(!require(MASS)) {
  install.packages("MASS")
  library(MASS)
}

# Robust regression is less affected by outliers
robust_model <- rlm(cases ~ rainfall_mm + temperature_avg + humidity_percent, 
                  data = malaria_data)
summary(robust_model)

# Compare coefficients between ordinary and robust regression
coef_comparison <- data.frame(
  Predictor = names(coef(step_model)),
  OLS = coef(step_model),
  Robust = c(coef(robust_model), NA)[1:length(coef(step_model))],  # Adjust length if different
  row.names = NULL
)

print(coef_comparison)
            </code>
        </div>
        
        <div class="explanation">
p-value`[coef_table$Variable == "rainfall_mm"] < 0.05)){paste("Rainfall is a significant predictor of malaria cases. For each 1 mm increase in monthly rainfall, we expect an increase of approximately", round(coef_table$Coefficient[coef_table$Variable == "rainfall_mm"], 2), "cases, holding other factors constant.")}`
# 
# 2. `r if(t_result$p.value < 0.05){paste("There is a significant difference in malaria cases between urban and rural areas, with", ifelse(t_result$estimate[2] > t_result$estimate[1], "rural", "urban"), "areas showing higher case counts. This suggests that targeted interventions should prioritize", ifelse(t_result$estimate[2] > t_result$estimate[1], "rural", "urban"), "communities.")}`
# 
# 3. The model diagnostics suggest `r if(shapiro.test(residuals(step_model))$p.value < 0.05){"some departure from normality in the residuals, which may affect the precision of our estimates."} else {"that the model assumptions are reasonably met."}`
# 
# ### Recommendations for Public Health Action:
# 
# 1. Time malaria prevention campaigns to coincide with or slightly precede periods of `r if(correlation_matrix[1,2] > 0){"increased rainfall"} else {"decreased rainfall"}`.
# 
# 2. Allocate resources differentially between urban and rural areas based on the observed differences in case burden.
# 
# 3. Continue monitoring environmental factors identified as significant predictors to improve early warning systems.
# 
# ### Limitations and Future Research:
# 
# - The model explains `r round(r_squared * 100, 1)`% of the variance, indicating other unmeasured factors influence malaria transmission.
# - Longitudinal studies are needed to establish stronger causal relationships.
# - Incorporating spatial analysis could provide additional insights into transmission patterns.
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî A comprehensive statistical report should include:<br>
            &nbsp;&nbsp;- Clear description of methods used<br>
            &nbsp;&nbsp;- Visual summaries of the data (tables, figures)<br>
            &nbsp;&nbsp;- Statistical test results with interpretation<br>
            &nbsp;&nbsp;- Discussion of practical significance beyond p-values<br>
            ‚úî Use R Markdown to combine code, results, and narrative in one document<br>
            ‚úî Inline R code (e.g., <code>`r round(correlation, 2)`</code>) dynamically inserts values into text<br>
            ‚úî Model limitations should be honestly acknowledged</p>
        </div>
        
        <hr>
        
        <h3>Step 2: Visualizing Statistical Results</h3>
        <div class="r-code">
            <code>
# Create more advanced visualizations of statistical results
# Install and load specialized packages
if(!require(ggpubr)) {
  install.packages("ggpubr")
  library(ggpubr)
}

if(!require(ggstatsplot)) {
  install.packages("ggstatsplot")
  library(ggstatsplot)
}

# Create a plot with statistical test results
ggbetweenstats(
  data = malaria_data,
  x = area_type,
  y = cases,
  type = "p", # p for parametric (t-test)
  plot.type = "box",
  pairwise.comparisons = TRUE,
  pairwise.display = "significant",
  centrality.plotting = TRUE,
  title = "Comparison of Malaria Cases by Area Type"
)

# Visualize correlation with statistical details
ggscatterstats(
  data = malaria_data,
  x = rainfall_mm,
  y = cases,
  xlab = "Monthly Rainfall (mm)",
  ylab = "Number of Malaria Cases",
  title = "Correlation between Rainfall and Malaria Cases"
)

# Create a regression coefficient plot
if(!require(sjPlot)) {
  install.packages("sjPlot")
  library(sjPlot)
}

# Plot regression coefficients with confidence intervals
plot_model(step_model, 
           show.values = TRUE, 
           value.offset = 0.3,
           vline.color = "red",
           sort.est = TRUE,
           title = "Regression Coefficients (Standardized)")

# Create a prediction plot
if(!require(effects)) {
  install.packages("effects")
  library(effects)
}

# Plot effect of rainfall on malaria cases
rainfall_effect <- allEffects(step_model)
plot(rainfall_effect$rainfall_mm, 
     main = "Effect of Rainfall on Predicted Malaria Cases",
     xlab = "Monthly Rainfall (mm)",
     ylab = "Predicted Malaria Cases")
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî <code>ggbetweenstats()</code> creates boxplots with statistical test results<br>
            ‚úî <code>ggscatterstats()</code> adds correlation statistics to scatter plots<br>
            ‚úî <code>plot_model()</code> visualizes regression coefficients with confidence intervals<br>
            ‚úî <code>allEffects()</code> shows how predicted values change across the range of a predictor<br>
            ‚úî These visualizations combine data, statistical results, and uncertainty in a single figure</p>
        </div>
        
        <hr>
        
        <h3>Step 3: Interpreting Effect Sizes</h3>
        <div class="r-code">
            <code>
# Calculate and interpret effect sizes for various statistical tests
if(!require(effectsize)) {
  install.packages("effectsize")
  library(effectsize)
}

# Cohen's d for t-test (standardized difference between means)
t_test_result <- t.test(
  filter(malaria_data, area_type == "Urban")$cases,
  filter(malaria_data, area_type == "Rural")$cases
)

cohens_d <- cohens_d(
  filter(malaria_data, area_type == "Urban")$cases,
  filter(malaria_data, area_type == "Rural")$cases
)

print(cohens_d)

# Interpret Cohen's d:
# |d| < 0.2: "negligible"
# |d| < 0.5: "small"
# |d| < 0.8: "medium"
# |d| >= 0.8: "large"

cat("Cohen's d =", round(as.numeric(cohens_d$Cohens_d), 2), 
    "- This represents a", 
    ifelse(abs(as.numeric(cohens_d$Cohens_d)) < 0.2, "negligible", 
           ifelse(abs(as.numeric(cohens_d$Cohens_d)) < 0.5, "small", 
                  ifelse(abs(as.numeric(cohens_d$Cohens_d)) < 0.8, "medium", "large"))),
    "effect size.\n")

# For correlation: r-squared as percentage of variance explained
correlation <- cor.test(malaria_data$cases, malaria_data$rainfall_mm)
r_squared <- correlation$estimate^2

cat("r¬≤ =", round(r_squared, 3), 
    "- Rainfall explains approximately", 
    round(r_squared * 100, 1), 
    "% of the variance in malaria cases.\n")

# For regression: standardized coefficients (beta weights)
# Scale the variables to get standardized coefficients
scaled_data <- malaria_data %>%
  mutate(across(where(is.numeric), scale))

std_model <- lm(cases ~ rainfall_mm + temperature_avg + humidity_percent, 
               data = scaled_data)

std_coef <- coef(std_model)
std_coef_df <- data.frame(
  Variable = names(std_coef),
  Standardized_Coefficient = as.numeric(std_coef)
)

print(std_coef_df)

cat("The standardized coefficients show that a 1 standard deviation change in",
    std_coef_df$Variable[which.max(abs(std_coef_df$Standardized_Coefficient[-1])) + 1],
    "has the largest effect on malaria cases.\n")

# For ANOVA: eta-squared and omega-squared
anova_model <- aov(cases ~ region, data = malaria_data)
eta_result <- eta_squared(anova_model)
omega_result <- omega_squared(anova_model)

print(eta_result)
print(omega_result)

# Interpret eta-squared/omega-squared:
# < 0.01: "negligible"
# < 0.06: "small"
# < 0.14: "medium"
# >= 0.14: "large"
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî Effect sizes quantify the practical significance of findings beyond p-values<br>
            ‚úî <code>cohens_d()</code> measures the standardized difference between two means<br>
            ‚úî <code>r¬≤</code> represents the proportion of variance explained by a correlation<br>
            ‚úî Standardized regression coefficients allow comparison of predictors on different scales<br>
            ‚úî <code>eta_squared()</code> and <code>omega_squared()</code> quantify the proportion of variance explained by categorical predictors</p>
        </div>
        
        <hr>
        
        <h3>Step 4: Reproducible Research Practices</h3>
        <div class="r-code">
            <code>
# Set up a reproducible research workflow
# This would typically be at the beginning of your R script or R Markdown document

# 1. Set a random seed for reproducible results
set.seed(123)

# 2. Document package versions
if(!require(sessioninfo)) {
  install.packages("sessioninfo")
  library(sessioninfo)
}

session_info <- sessioninfo::session_info()
print(session_info$platform)
print(session_info$packages)

# 3. Save raw data separately from processed data
# Create a data processing script that documents all transformations

# Example data processing pipeline
raw_data <- read.csv("raw_malaria_data.csv")

processed_data <- raw_data %>%
  # Document each transformation step
  filter(!is.na(cases)) %>%  # Remove missing case data
  mutate(
    # Create derived variables
    log_cases = log(cases + 1),  # Log transform with +1 for zeros
    season = case_when(
      month %in% c(6, 7, 8, 9) ~ "Rainy",
      TRUE ~ "Dry"
    ),
    # Other transformations...
  )

# Save processed data with date stamp
write.csv(processed_data, 
         paste0("processed_malaria_data_", format(Sys.Date(), "%Y%m%d"), ".csv"), 
         row.names = FALSE)

# 4. Use version control (typically Git) 
# This would be done outside of R, but you can use system commands
# system("git add processed_malaria_data_*.csv")
# system("git commit -m 'Process raw data with documented transformations'")

# 5. Pre-register analyses when possible
# This would involve creating a document that specifies:
#  - Research questions/hypotheses
#  - Variables to be used
#  - Statistical methods to be employed
#  - Sample size/power calculations
#  - Data exclusion criteria

# 6. Share code and data when possible
# Example using R Open Science tools
if(!require(piggyback)) {
  install.packages("piggyback")
  library(piggyback)
}

# This would upload your data to a GitHub repository release
# pb_upload("processed_malaria_data.csv", repo = "username/repository")

# 7. Create a research compendium
# Directory structure for a reproducible project:
# project/
# ‚îú‚îÄ‚îÄ README.md           # Overview of the project
# ‚îú‚îÄ‚îÄ LICENSE.md          # License for code and data
# ‚îú‚îÄ‚îÄ data/
# ‚îÇ   ‚îú‚îÄ‚îÄ raw/            # Raw, immutable data
# ‚îÇ   ‚îî‚îÄ‚îÄ processed/      # Processed data, ready for analysis
# ‚îú‚îÄ‚îÄ code/
# ‚îÇ   ‚îú‚îÄ‚îÄ process_data.R  # Data processing script
# ‚îÇ   ‚îî‚îÄ‚îÄ analysis.R      # Analysis script
# ‚îú‚îÄ‚îÄ results/
# ‚îÇ   ‚îú‚îÄ‚îÄ figures/        # Generated figures
# ‚îÇ   ‚îî‚îÄ‚îÄ tables/         # Generated tables
# ‚îî‚îÄ‚îÄ manuscript/         # Manuscript text and source files
            </code>
        </div>
        
        <div class="explanation">
            <h4>üîç Explanation:</h4>
            <p>‚úî Reproducible research allows others to verify and build upon your findings<br>
            ‚úî <code>set.seed()</code> ensures that random processes produce the same results<br>
            ‚úî Documenting package versions helps prevent issues from software changes<br>
            ‚úî Separating data processing from analysis creates a clear workflow<br>
            ‚úî Using version control tracks changes to code and data over time<br>
            ‚úî Pre-registration reduces the risk of p-hacking and publication bias<br>
            ‚úî Sharing code and data promotes transparency and collaboration</p>
        </div>
        
        <hr>
        
        <h2>‚úÖ Summary of Week 6</h2>
        <p>By the end of this week, you should be able to:<br>
        ‚úî <strong>Compare malaria data between groups</strong> using appropriate statistical tests (t-tests, ANOVA)<br>
        ‚úî <strong>Analyze relationships between variables</strong> using correlation analysis<br>
        ‚úî <strong>Build and interpret regression models</strong> to identify significant predictors of malaria<br>
        ‚úî <strong>Present statistical results</strong> in a clear, comprehensive, and interpretable manner<br>
        ‚úî <strong>Apply reproducible research practices</strong> to ensure the validity and reusability of your analyses</p>
     
       
